syntax="proto3";

package BtcLsp.Type;

import "btc_lsp/newtype.proto";

message Ctx {
  .BtcLsp.Newtype.Nonce nonce = 1;
  .BtcLsp.Newtype.LnPubKey ln_pub_key = 2;
}

message Cfg {
  .BtcLsp.Newtype.LocalBalance open_chan_min_local_balance = 1;
  .BtcLsp.Newtype.LocalBalance open_chan_max_local_balance = 2;
  .BtcLsp.Newtype.RemoteBalance open_chan_min_remote_balance = 3;
  .BtcLsp.Newtype.RemoteBalance open_chan_max_remote_balance = 4;
  FeeRate open_chan_remote_balance_fee_rate = 5;
  .BtcLsp.Newtype.Msat open_chan_min_fee_amt = 6;
  //
  // TODO : add open/close sat/vb fees
  //
}

message Rational {
  bool negative = 1;
  uint64 numerator = 2;
  uint64 denominator = 3;
}

message Urational {
  uint64 numerator = 1;
  uint64 denominator = 2;
}

message FeeRate {
  Urational val = 1;
}

message InputFailure {
  repeated .BtcLsp.Newtype.FieldIndex field_location = 1;
  InputFailureKind kind = 2;
}

enum InputFailureKind {
  // All proto3 messages are optional, but sometimes
  // message presence is required by source code.
  REQUIRED = 0;
  // Sometimes protobuf term is not data itself, but reference
  // to some other data, located somewhere else, for example
  // in database, and this resource might be not found.
  NOT_FOUND = 1;
  // Sometimes data is required to be in some
  // specific format (for example DER binary encoding)
  // which is not the part of proto3 type system.
  // This error shows the failure of custom parser.
  PARSING_FAILED = 2;
  // Even if custom parser succeeded, sometimes data
  // needs to be verified somehow, for example
  // signature needs to be cryptographically verified.
  VERIFICATION_FAILED = 3;
}
