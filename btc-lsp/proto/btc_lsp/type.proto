syntax="proto3";

package BtcLsp.Type;

import "btc_lsp/newtype.proto";

message Ctx {
  .BtcLsp.Newtype.Nonce nonce = 1;
  .BtcLsp.Newtype.LnPubKey ln_pub_key = 2;
}

message Cfg {
  MsatLimit open_chan_ln_limit = 1;
  SatLimit open_chan_on_chain_limit = 2;
  FeeRate open_chan_fee_rate = 3;
  .BtcLsp.Newtype.Msat open_chan_min_fee = 4;
}

message MsatLimit {
  .BtcLsp.Newtype.Msat min = 1;
  .BtcLsp.Newtype.Msat max = 2;
}

message SatLimit {
  .BtcLsp.Newtype.Sat min = 1;
  .BtcLsp.Newtype.Sat max = 2;
}

message Rational {
  bool negative = 1;
  uint64 numerator = 2;
  uint64 denominator = 3;
}

message URational {
  uint64 numerator = 1;
  uint64 denominator = 2;
}

message FeeRate {
  URational val = 1;
}

message InputFailure {
  repeated .BtcLsp.Newtype.FieldIndex field_location = 1;
  InputFailureKind kind = 2;
}

enum InputFailureKind {
  // All proto3 messages are optional, but sometimes
  // message presence is required by source code.
  REQUIRED = 0;
  // Sometimes protobuf term is not data itself, but reference
  // to some other data, located somewhere else, for example
  // in database, and this resource might be not found.
  NOT_FOUND = 1;
  // Sometimes data is required to be in some
  // specific format (for example DER binary encoding)
  // which is not the part of proto3 type system.
  // This error shows the failure of custom parser.
  PARSING_FAILED = 2;
  // Even if custom parser succeeded, sometimes data
  // needs to be verified somehow, for example
  // signature needs to be cryptographically verified.
  VERIFICATION_FAILED = 3;
}
