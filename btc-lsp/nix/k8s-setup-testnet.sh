#!/bin/bash

set -e

BITCOIN_NETWORK="testnet"
THIS_DIR="$(dirname "$(realpath "$0")")"
BUILD_DIR="$THIS_DIR/../build"

# Dirs with service-specific files
BITCOIND_PATH="$BUILD_DIR/bitcoind"
LND_PATH="$BUILD_DIR/lnd"
RTL_PATH="$BUILD_DIR/rtl"
LSP_PATH=="$BUILD_DIR/lsp"
POSTGRES_PATH=="$BUILD_DIR/postgres"

# Save all LetsEncrypt stuff here
LETSENCRYPT_DIR="$BUILD_DIR/letsencrypt"

# Save root domain here
DOMAIN_PATH="$BUILD_DIR/domain.txt"

# Save Postgres connection string here
PG_CONN_PATH="$POSTGRES_PATH/conn.txt"

# Name to use when creating resources within cloud provider
CLOUD_RESOURCE_NAME="lsp-$BITCOIN_NETWORK"

isInstalled () {
  if ! command -v "$1" &> /dev/null; then
    echo "Please install \"$1\" before proceeding"
    exit 1;
  fi
}

confirmAction () {
  while true; do
    read -p "$1 (y/N) ? " ANSWER
    case "$ANSWER" in
      [Yy]* ) eval "$2"; break;;
      [Nn]* ) break;;
      * ) echo "Please answer yes or no.";;
    esac
  done
}

cleanBuildDir () {
  echo "Deleting everything in $BUILD_DIR"
  rm -rf "$BUILD_DIR" && mkdir -p $BUILD_DIR

  echo "==> Generating new creds"
  sh "$THIS_DIR/hm-shell-docker.sh" --mini \
   "--run './nix/ns-gen-creds.sh && ./nix/ns-inline-creds.sh'"
}

getLetsEncryptCert () {
  echo "Requesting cert for $1..."
  certbot certonly \
    -d "*.$1" \
    --agree-tos \
    --manual \
    --preferred-challenges dns \
    --register-unsafely-without-email \
    --config-dir "$LETSENCRYPT_DIR/etc" \
    --work-dir "$LETSENCRYPT_DIR/lib" \
    --logs-dir "$LETSENCRYPT_DIR/log"
}

copyLetsEncryptCert () {
  COPY_PATH="$1"
  CERT_PATH="$LETSENCRYPT_DIR/etc/live/$DOMAIN"

  echo "Copying files generated by LetsEncrypt to $COPY_PATH"
  cp "$CERT_PATH/cert.pem" "$COPY_PATH/tls.cert"
  cp "$CERT_PATH/privkey.pem" "$COPY_PATH/tls.key"
}

isCertProvided () {
  for FILENAME in tls.cert tls.key; do
    FILEPATH="$1/$FILENAME"

    if [ ! -f "$FILEPATH" ]; then
      echo "File not found at $FILEPATH"
      exit 1;
    fi
  done
}

setupLetsEncryptCert() {
  isInstalled certbot && \
  mkdir -p "$LETSENCRYPT_DIR" && \
  getLetsEncryptCert "$DOMAIN" && \
  copyLetsEncryptCert "$RTL_PATH" && \
  copyLetsEncryptCert "$LSP_PATH"
}

createKubernetesCluster () {
  echo "Creating \"$1\" k8s cluster on DigitalOcean..."
  doctl kubernetes cluster create "$1" \
    --count 3 \
    --region ams3 \
    --1-clicks ingress-nginx \
    --size s-4vcpu-8gb
}

deleteKubernetesCluster () {
  echo "Deleting \"$1\" k8s cluster from DigitalOcean..."
  doctl kubernetes cluster delete "$1" --dangerous
}

setupKubernetesCluster () {
  isInstalled doctl && \
  doctl account get && \
  K8S_CLUSTER_NAME="$1"

  if doctl kubernetes cluster get "$K8S_CLUSTER_NAME"; then
    confirmAction \
    "==> Delete existing \"$K8S_CLUSTER_NAME\" k8s cluster and create a new one?" \
    "deleteKubernetesCluster $K8S_CLUSTER_NAME && createKubernetesCluster $K8S_CLUSTER_NAME"
  else
    confirmAction \
    "==> Create new \"$K8S_CLUSTER_NAME\" k8s cluster?" \
    "createKubernetesCluster $K8S_CLUSTER_NAME"
  fi
}

getPostgresInstanceId () {
  doctl databases list --no-header | grep "$1" | awk '{print $1}'
}

createPostgresInstance () {
  echo "Creating \"$1\" database instance on DigitalOcean..."
  doctl databases create "$1" \
    --engine pg \
    --region ams3 \
    --size db-s-1vcpu-1gb
}

deletePostgresInstance () {
  echo "Deleting \"$1\" database instance from DigitalOcean..."
  PG_INSTANCE_ID=`getPostgresInstanceId $1`
  doctl databases delete "$PG_INSTANCE_ID"
}

writePostgresURI() {
  PG_INSTANCE_ID=`getPostgresInstanceId $1`
  PG_URI=`doctl databases connection $PG_INSTANCE_ID --format URI --no-header`
  echo "Saving connection details to $PG_CONN_PATH"
  echo -n "$PG_URI" > "$PG_CONN_PATH"
}

recreatePostgresInstance () {
  deletePostgresInstance "$1" && \
  createPostgresInstance "$1" && \
  writePostgresURI "$1"
}

setupPostgresInstance () {
  isInstalled doctl && \
  doctl account get && \
  PG_INSTANCE_NAME="$1"
  PG_INSTANCE_ID=`getPostgresInstanceId $PG_INSTANCE_NAME`

  if [ -n "$PG_INSTANCE_ID" ]; then
    confirmAction \
    "==> Delete existing \"$PG_INSTANCE_NAME\" database instance and create a new one?" \
    "recreatePostgresInstance $PG_INSTANCE_NAME"
  else
    confirmAction \
    "==> Create new \"$PG_INSTANCE_NAME\" database instance?" \
    "createPostgresInstance $PG_INSTANCE_NAME && writePostgresURI $PG_INSTANCE_NAME"
  fi
}

confirmAction \
"==> Clean up previous build?" \
"cleanBuildDir"

if [ ! -f "$DOMAIN_PATH" ]; then
  echo "==> Domain name must be set before continuing"
  read -p "Input your domain name: " "DOMAIN"
  echo "Saving $DOMAIN to $DOMAIN_PATH"
  echo -n "$DOMAIN" > "$DOMAIN_PATH"
fi

confirmAction \
"==> Setup LetsEncrypt certificate?" \
"setupLetsEncryptCert"

echo "==> Checking that tls certs for \"rtl\" and \"lsp\" are provided"
isCertProvided "$RTL_PATH" && isCertProvided "$LSP_PATH"
echo "Certs are OK."

setupKubernetesCluster "$CLOUD_RESOURCE_NAME"
setupPostgresInstance "$CLOUD_RESOURCE_NAME"

echo "==> Partial dhall"
sh "$THIS_DIR/hm-shell-docker.sh" --mini \
   "--run './nix/k8s-dhall-compile.sh $BITCOIN_NETWORK'"

echo "==> Configuring environment for containers"
sh "$THIS_DIR/k8s-setup-env.sh" "$BITCOIN_NETWORK"

echo "==> Deploying k8s resources"
sh "$THIS_DIR/k8s-deploy.sh" "bitcoind lnd"

echo "==> Waiting until containers are ready"
sh "$THIS_DIR/k8s-wait.sh" "bitcoind lnd"

echo "==> Partial spin"
sh "$THIS_DIR/k8s-lazy-init-unlock.sh"
sleep 20

echo "==> Exporting creds from running pods"
sh "$THIS_DIR/k8s-export-creds.sh"

echo "==> Full dhall"
sh "$THIS_DIR/hm-shell-docker.sh" --mini \
   "--run './nix/ns-inline-creds.sh && ./nix/k8s-dhall-compile.sh $BITCOIN_NETWORK'"

echo "==> Configuring environment for containers"
sh "$THIS_DIR/k8s-setup-env.sh" "$BITCOIN_NETWORK"

echo "==> Deploying additional k8s resources"
sh "$THIS_DIR/k8s-deploy.sh" "rtl lsp"

echo "==> Waiting until containers are ready"
sh "$THIS_DIR/k8s-wait.sh" "rtl lsp"

echo "==> Setup for $BITCOIN_NETWORK has been completed!"
